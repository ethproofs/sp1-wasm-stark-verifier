//! A simple wrapper around the `sp1_verifier` crate.

use core::error::Error;
use std::fmt::Debug;

use serde::{Deserialize, Serialize};
use sp1_primitives::io::SP1PublicValues;
use sp1_stark::baby_bear_poseidon2::BabyBearPoseidon2;
use sp1_stark::SP1ReduceProof;
use sp1_verifier::compressed::SC;
use sp1_verifier::{
    CompressedError, CompressedVerifier, Groth16Verifier, PlonkVerifier, GROTH16_VK_BYTES,
    PLONK_VK_BYTES,
};
use strum_macros::{EnumDiscriminants, EnumTryAs};
use wasm_bindgen::prelude::*;

// Enable console.log! macro for debugging
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);
}

macro_rules! console_log {
    ($($t:tt)*) => (log(&format_args!($($t)*).to_string()))
}

// Set up panic hook for better error messages
#[wasm_bindgen(start)]
pub fn main() {
    console_error_panic_hook::set_once();
}

/// Wrapper around [`sp1_verifier::Groth16Verifier::verify`].
///
/// We hardcode the Groth16 VK bytes to only verify SP1 proofs.
#[wasm_bindgen]
pub fn verify_groth16(proof: &[u8], public_inputs: &[u8], sp1_vk_hash: &str) -> bool {
    handle_result(Groth16Verifier::verify(
        proof,
        public_inputs,
        sp1_vk_hash,
        *GROTH16_VK_BYTES,
    ))
}

/// Wrapper around [`sp1_verifier::PlonkVerifier::verify`].
///
/// We hardcode the Plonk VK bytes to only verify SP1 proofs.
#[wasm_bindgen]
pub fn verify_plonk(proof: &[u8], public_inputs: &[u8], sp1_vk_hash: &str) -> bool {
    handle_result(PlonkVerifier::verify(
        proof,
        public_inputs,
        sp1_vk_hash,
        *PLONK_VK_BYTES,
    ))
}

/// Copied from sp1-sdk
///
/// The configuration for the inner prover.
pub type InnerSC = BabyBearPoseidon2;

/// Copied from sp1-sdk
///
/// A proof generated by the SP1 RISC-V zkVM.
#[derive(Debug, Clone, Serialize, Deserialize, EnumDiscriminants, EnumTryAs)]
#[strum_discriminants(derive(Default, Hash, PartialOrd, Ord))]
#[strum_discriminants(name(SP1ProofMode))]
pub enum SP1Proof {
    /// A proof generated by the compress proof mode.
    ///
    /// The proof size is constant, regardless of the number of cycles.
    #[strum_discriminants(default)]
    Compressed(Box<SP1ReduceProof<InnerSC>>),
}

// Copied from sp1-sdk
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SP1ProofWithPublicValues {
    /// The raw proof generated by the SP1 RISC-V zkVM.
    pub proof: SP1Proof,
    /// The public values generated by the SP1 RISC-V zkVM.
    pub public_values: SP1PublicValues,
    /// The version of the SP1 RISC-V zkVM (not necessary but useful for detecting version
    /// mismatches).
    pub sp1_version: String,
    /// The integrity proof generated by the TEE server.
    pub tee_proof: Option<Vec<u8>>,
}

#[wasm_bindgen]
pub fn verify_stark(proof: &[u8], sp1_vk: &[u8]) -> Result<bool, JsValue> {
    console_log!(
        "Starting verification with proof size: {}, sp1_vk size: {}",
        proof.len(),
        sp1_vk.len()
    );

    let proof_with_public_values: SP1ProofWithPublicValues =
        bincode::deserialize(proof).expect("Failed to deserialize proof");

    let reduce_proof: Box<SP1ReduceProof<SC>> = bincode::deserialize(proof)
        .map_err(CompressedError::DeserializeProof)
        .expect("Failed to deserialize reduce proof");
    let proof_bytes = bincode::serialize(&reduce_proof).expect("Failed to serialize reduce proof");
    let public_values_bytes = bincode::serialize(&proof_with_public_values.public_values)
        .expect("Failed to serialize public values");

    let result = verify_compressed(&proof_bytes, &public_values_bytes, sp1_vk);
    console_log!("Verification result: {:?}", result);
    Ok(result)
}

/// Wrapper around [`sp1_verifier::CompressedVerifier::verify`].
#[wasm_bindgen]
pub fn verify_compressed(proof: &[u8], public_inputs: &[u8], sp1_vk_hash: &[u8]) -> bool {
    handle_result(CompressedVerifier::verify(
        proof,
        public_inputs,
        sp1_vk_hash,
    ))
}

/// Prints errors via `console.error`.
///
/// Returns whether the variant was `Result::Ok`.
fn handle_result<T, E: Error>(res: Result<T, E>) -> bool {
    res.inspect_err(|e| console::error(&format!("{e}"))).is_ok()
}

mod console {
    use super::wasm_bindgen;

    #[wasm_bindgen(js_namespace = console)]
    extern "C" {
        #[wasm_bindgen]
        pub fn error(s: &str);
    }
}
